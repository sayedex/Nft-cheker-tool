"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const eventemitter3_1 = tslib_1.__importDefault(require("eventemitter3"));
const client_1 = tslib_1.__importDefault(require("@walletconnect/client"));
const qrcode_modal_1 = tslib_1.__importDefault(require("@walletconnect/qrcode-modal"));
const utils_1 = require("@walletconnect/utils");
class WCRpcConnection extends eventemitter3_1.default {
    constructor(opts) {
        super();
        this.bridge = "https://bridge.walletconnect.org";
        this.qrcode = true;
        this.qrcodeModalOptions = undefined;
        this.chainId = 1;
        this.connected = false;
        this.bridge = (opts === null || opts === void 0 ? void 0 : opts.connector)
            ? opts.connector.bridge
            : (opts === null || opts === void 0 ? void 0 : opts.bridge) || "https://bridge.walletconnect.org";
        this.qrcode = typeof (opts === null || opts === void 0 ? void 0 : opts.qrcode) === "undefined" || opts.qrcode !== false;
        this.chainId = typeof (opts === null || opts === void 0 ? void 0 : opts.chainId) !== "undefined" ? opts.chainId : 1;
        this.qrcodeModalOptions = opts === null || opts === void 0 ? void 0 : opts.qrcodeModalOptions;
        this.wc =
            (opts === null || opts === void 0 ? void 0 : opts.connector) ||
                new client_1.default({
                    bridge: this.bridge,
                    qrcodeModal: this.qrcode ? qrcode_modal_1.default : undefined,
                    qrcodeModalOptions: this.qrcodeModalOptions,
                    clientMeta: opts === null || opts === void 0 ? void 0 : opts.clientMeta,
                });
        if (this.wc.connected) {
            this.connected = true;
        }
        this.on("error", () => this.close());
    }
    get connector() {
        return this.wc;
    }
    create() {
        if (!this.wc.connected) {
            this.wc
                .createSession({ chainId: this.chainId })
                .then(() => this.emit("created"))
                .catch((e) => this.emit("error", e));
        }
        this.wc.on("modal_closed", () => {
            this.emit("error", new Error("User closed modal"));
        });
        this.wc.on("connect", (err) => {
            if (err) {
                this.emit("error", err);
                return;
            }
            this.onOpen();
        });
        this.wc.on("disconnect", (err) => {
            if (err) {
                this.emit("error", err);
                return;
            }
            this.onClose();
        });
    }
    onOpen() {
        this.connected = true;
        this.emit("connect");
        this.emit("open");
    }
    onClose() {
        this.wc = new client_1.default({
            bridge: this.bridge,
            qrcodeModalOptions: this.qrcodeModalOptions,
        });
        this.connected = false;
        this.emit("close");
        this.emit("disconnect");
        this.removeAllListeners();
    }
    open() {
        if (this.connected) {
            this.onOpen();
            return Promise.resolve();
        }
        return new Promise((resolve, reject) => {
            this.on("error", err => {
                reject(err);
            });
            this.on("connect", () => {
                resolve();
            });
            this.create();
        });
    }
    close() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (this.wc.connected) {
                this.wc.killSession();
            }
            this.onClose();
            return Promise.resolve();
        });
    }
    onError(payload, message = "Failed or Rejected Request", code = -32000) {
        const errorPayload = {
            id: payload.id,
            jsonrpc: payload.jsonrpc,
            error: { code, message },
        };
        this.emit("payload", errorPayload);
        return errorPayload;
    }
    sendPayload(payload) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.wc || !this.wc.connected) {
                return this.onError(payload, "WalletConnect Not Connected");
            }
            try {
                return this.wc.unsafeSend(payload);
            }
            catch (error) {
                return this.onError(payload, error.message);
            }
        });
    }
    send(payload) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const response = yield this.sendPayload(payload);
            if (utils_1.isJsonRpcResponseError(response)) {
                throw new Error(response.error.message || "Failed or Rejected Request");
            }
            return response.result;
        });
    }
}
exports.default = WCRpcConnection;
//# sourceMappingURL=index.js.map